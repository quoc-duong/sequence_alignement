import argparse

def parse_options():
    parser = argparse.ArgumentParser(description='Search subsequence in a genome following the strategy of the bowtie tool')
    parser.add_argument("infile", help="Input file that is generated by bw-build")
    parser.add_argument("q", help="Sequence to process")
    parser.add_argument("--count-only", dest='count_only', help="Only print the number of matches", action='store_true')
    return parser.parse_args()

def bw_inverse_transform(bw_transformed):
    table = [""] * len(bw_transformed)
    for _ in range(len(bw_transformed)):
        table = sorted(bw_transformed[i] + table[i] for i in range(len(bw_transformed)))
    return table

def get_occurrence(c, upper_bound, table):
    nb_occ = 0

    for i in range(upper_bound):
        if table[i][-1] == c:
            nb_occ += 1

    return nb_occ

def create_C(table):
    C = {}
    C_index = []
    index = 0

    for i in range(len(table)):
        if table[i][0] not in C:
            C[table[i][0]] = index
            C_index.append(i)
            index += 1

    C_index.append(i)
    return C, C_index

def search(table, q):
    C, C_index = create_C(table)
    p = len(q) - 1
    c, i = q[p], p
    sp, ep = C_index[C[c]] + 1, C_index[C[c] + 1]

    while (sp <= ep and i > 0):
        c = q[i - 1]
        sp = C_index[C[c]] + get_occurrence(c, sp - 1, table) + 1
        ep = C_index[C[c]] + get_occurrence(c, ep, table)
        i -= 1

    return sp - 1, ep

def decompress(bw_transformed):
    ATGC_dict = {
        0b00: 'A',
        0b01: 'C',
        0b10: 'G',
        0b11: 'T'
    }
    result = ""
    for i in range(len(bw_transformed)):
        temp = bw_transformed[i]
        for _ in range(4):
            result += ATGC_dict[temp & 0b11]
            temp = temp >> 2

    return result


def bw_search():
    args = parse_options()

    with open(args.infile, "rb") as infile:
        c, n, p, f = [int(e) for e in infile.readline().split()]
        positions_index = infile.readline()
        bw_tranformed = infile.readlines()[0]

    if c:
        bw_transformed = decompress(bw_tranformed)
        bw_transformed = bw_transformed[:n] + '$' + bw_transformed[n:len(bw_transformed) - p]
    else:
        bw_transformed = bw_tranformed.decode('ascii')

    table = bw_inverse_transform(bw_transformed)
    sp, ep = search(table, args.q)

    if args.count_only:
        print(ep - sp)
    else:
        for row in table[sp:ep]:
            print(len(row) - row.index('$') - 1)

if __name__ == "__main__":
    bw_search()